# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbtypes

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# parameters and data of the active command
class AxsCmdValues(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AxsCmdValues()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAxsCmdValues(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AxsCmdValues
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # commanded target position
    # AxsCmdValues
    def TargetPos(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # commanded target velocity (currently not supported)
    # AxsCmdValues
    def TargetVel(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # commanded target torque (currently not supported)
    # AxsCmdValues
    def TargetTrq(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Float64Flags, o + self._tab.Pos)
        return 0.0

    # dynamic limits for the motion of this command
    # AxsCmdValues
    def Lim(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.DynamicLimitsState import DynamicLimitsState
            obj = DynamicLimitsState()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # command ID of the active command
    # AxsCmdValues
    def CmdId(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Uint64Flags, o + self._tab.Pos)
        return 0

    # command source (by which interface was this command inserted into the system (e.g. "PLC"))
    # AxsCmdValues
    def Src(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.CmdSource import CmdSource
            obj = CmdSource()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # unit of the commanded target position
    # AxsCmdValues
    def TargetPosUnit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # unit of the commanded target velocity (currently not supported)
    # AxsCmdValues
    def TargetVelUnit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # unit of the commanded target torque (currently not supported)
    # AxsCmdValues
    def TargetTrqUnit(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def AxsCmdValuesStart(builder): builder.StartObject(9)
def Start(builder):
    return AxsCmdValuesStart(builder)
def AxsCmdValuesAddTargetPos(builder, targetPos): builder.PrependFloat64Slot(0, targetPos, 0.0)
def AddTargetPos(builder, targetPos):
    return AxsCmdValuesAddTargetPos(builder, targetPos)
def AxsCmdValuesAddTargetVel(builder, targetVel): builder.PrependFloat64Slot(1, targetVel, 0.0)
def AddTargetVel(builder, targetVel):
    return AxsCmdValuesAddTargetVel(builder, targetVel)
def AxsCmdValuesAddTargetTrq(builder, targetTrq): builder.PrependFloat64Slot(2, targetTrq, 0.0)
def AddTargetTrq(builder, targetTrq):
    return AxsCmdValuesAddTargetTrq(builder, targetTrq)
def AxsCmdValuesAddLim(builder, lim): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(lim), 0)
def AddLim(builder, lim):
    return AxsCmdValuesAddLim(builder, lim)
def AxsCmdValuesAddCmdId(builder, cmdId): builder.PrependUint64Slot(4, cmdId, 0)
def AddCmdId(builder, cmdId):
    return AxsCmdValuesAddCmdId(builder, cmdId)
def AxsCmdValuesAddSrc(builder, src): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(src), 0)
def AddSrc(builder, src):
    return AxsCmdValuesAddSrc(builder, src)
def AxsCmdValuesAddTargetPosUnit(builder, targetPosUnit): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(targetPosUnit), 0)
def AddTargetPosUnit(builder, targetPosUnit):
    return AxsCmdValuesAddTargetPosUnit(builder, targetPosUnit)
def AxsCmdValuesAddTargetVelUnit(builder, targetVelUnit): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(targetVelUnit), 0)
def AddTargetVelUnit(builder, targetVelUnit):
    return AxsCmdValuesAddTargetVelUnit(builder, targetVelUnit)
def AxsCmdValuesAddTargetTrqUnit(builder, targetTrqUnit): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(targetTrqUnit), 0)
def AddTargetTrqUnit(builder, targetTrqUnit):
    return AxsCmdValuesAddTargetTrqUnit(builder, targetTrqUnit)
def AxsCmdValuesEnd(builder): return builder.EndObject()
def End(builder):
    return AxsCmdValuesEnd(builder)
import motion.core.fbtypes.CmdSource
import motion.core.fbtypes.DynamicLimitsState
try:
    from typing import Optional
except:
    pass

class AxsCmdValuesT(object):

    # AxsCmdValuesT
    def __init__(self):
        self.targetPos = 0.0  # type: float
        self.targetVel = 0.0  # type: float
        self.targetTrq = 0.0  # type: float
        self.lim = None  # type: Optional[motion.core.fbtypes.DynamicLimitsState.DynamicLimitsStateT]
        self.cmdId = 0  # type: int
        self.src = None  # type: Optional[motion.core.fbtypes.CmdSource.CmdSourceT]
        self.targetPosUnit = None  # type: str
        self.targetVelUnit = None  # type: str
        self.targetTrqUnit = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        axsCmdValues = AxsCmdValues()
        axsCmdValues.Init(buf, pos)
        return cls.InitFromObj(axsCmdValues)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, axsCmdValues):
        x = AxsCmdValuesT()
        x._UnPack(axsCmdValues)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.targetPos == other.targetPos and \
            self.targetVel == other.targetVel and \
            self.targetTrq == other.targetTrq and \
            self.lim == other.lim and \
            self.cmdId == other.cmdId and \
            self.src == other.src and \
            self.targetPosUnit == other.targetPosUnit and \
            self.targetVelUnit == other.targetVelUnit and \
            self.targetTrqUnit == other.targetTrqUnit

    # AxsCmdValuesT
    def _UnPack(self, axsCmdValues):
        if axsCmdValues is None:
            return
        self.targetPos = axsCmdValues.TargetPos()
        self.targetVel = axsCmdValues.TargetVel()
        self.targetTrq = axsCmdValues.TargetTrq()
        if axsCmdValues.Lim() is not None:
            self.lim = motion.core.fbtypes.DynamicLimitsState.DynamicLimitsStateT.InitFromObj(axsCmdValues.Lim())
        self.cmdId = axsCmdValues.CmdId()
        if axsCmdValues.Src() is not None:
            self.src = motion.core.fbtypes.CmdSource.CmdSourceT.InitFromObj(axsCmdValues.Src())
        self.targetPosUnit = axsCmdValues.TargetPosUnit()
        self.targetVelUnit = axsCmdValues.TargetVelUnit()
        self.targetTrqUnit = axsCmdValues.TargetTrqUnit()

    # AxsCmdValuesT
    def Pack(self, builder):
        if self.lim is not None:
            lim = self.lim.Pack(builder)
        if self.src is not None:
            src = self.src.Pack(builder)
        if self.targetPosUnit is not None:
            targetPosUnit = builder.CreateString(self.targetPosUnit)
        if self.targetVelUnit is not None:
            targetVelUnit = builder.CreateString(self.targetVelUnit)
        if self.targetTrqUnit is not None:
            targetTrqUnit = builder.CreateString(self.targetTrqUnit)
        AxsCmdValuesStart(builder)
        AxsCmdValuesAddTargetPos(builder, self.targetPos)
        AxsCmdValuesAddTargetVel(builder, self.targetVel)
        AxsCmdValuesAddTargetTrq(builder, self.targetTrq)
        if self.lim is not None:
            AxsCmdValuesAddLim(builder, lim)
        AxsCmdValuesAddCmdId(builder, self.cmdId)
        if self.src is not None:
            AxsCmdValuesAddSrc(builder, src)
        if self.targetPosUnit is not None:
            AxsCmdValuesAddTargetPosUnit(builder, targetPosUnit)
        if self.targetVelUnit is not None:
            AxsCmdValuesAddTargetVelUnit(builder, targetVelUnit)
        if self.targetTrqUnit is not None:
            AxsCmdValuesAddTargetTrqUnit(builder, targetTrqUnit)
        axsCmdValues = AxsCmdValuesEnd(builder)
        return axsCmdValues
