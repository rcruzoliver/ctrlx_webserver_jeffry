# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbtypes

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# complete configuration of a single axis
class AxsCfg(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = AxsCfg()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsAxsCfg(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # AxsCfg
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # object type (must be "Axis"), required for save/load
    # AxsCfg
    def ObjectType(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # name of the assigned axis profile or empty for virtual drives
    # AxsCfg
    def AxisProfileName(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # all configured limits of this axis
    # AxsCfg
    def Limits(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.AxsCfgLimits import AxsCfgLimits
            obj = AxsCfgLimits()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # configuration for specific functions of this axis
    # AxsCfg
    def Functions(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.AxsCfgFunctions import AxsCfgFunctions
            obj = AxsCfgFunctions()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # common axis properties of this axis
    # AxsCfg
    def Properties(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.AxsCfgProperties import AxsCfgProperties
            obj = AxsCfgProperties()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # general unit configuration of this axis
    # AxsCfg
    def Units(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.UnitCfgObj import UnitCfgObj
            obj = UnitCfgObj()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # kinematic properties for axes
    # AxsCfg
    def KinProperties(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.AxsCfgKinProperties import AxsCfgKinProperties
            obj = AxsCfgKinProperties()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # device error reation settings
    # AxsCfg
    def DevErrReaction(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.AxsCfgDeviceErrorReaction import AxsCfgDeviceErrorReaction
            obj = AxsCfgDeviceErrorReaction()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # configuration of the real-time inputs of the axis
    # AxsCfg
    def RtInputs(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from motion.core.fbtypes.RTInputsCfg import RTInputsCfg
            obj = RTInputsCfg()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def AxsCfgStart(builder): builder.StartObject(9)
def Start(builder):
    return AxsCfgStart(builder)
def AxsCfgAddObjectType(builder, objectType): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(objectType), 0)
def AddObjectType(builder, objectType):
    return AxsCfgAddObjectType(builder, objectType)
def AxsCfgAddAxisProfileName(builder, axisProfileName): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(axisProfileName), 0)
def AddAxisProfileName(builder, axisProfileName):
    return AxsCfgAddAxisProfileName(builder, axisProfileName)
def AxsCfgAddLimits(builder, limits): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(limits), 0)
def AddLimits(builder, limits):
    return AxsCfgAddLimits(builder, limits)
def AxsCfgAddFunctions(builder, functions): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(functions), 0)
def AddFunctions(builder, functions):
    return AxsCfgAddFunctions(builder, functions)
def AxsCfgAddProperties(builder, properties): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(properties), 0)
def AddProperties(builder, properties):
    return AxsCfgAddProperties(builder, properties)
def AxsCfgAddUnits(builder, units): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(units), 0)
def AddUnits(builder, units):
    return AxsCfgAddUnits(builder, units)
def AxsCfgAddKinProperties(builder, kinProperties): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(kinProperties), 0)
def AddKinProperties(builder, kinProperties):
    return AxsCfgAddKinProperties(builder, kinProperties)
def AxsCfgAddDevErrReaction(builder, devErrReaction): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(devErrReaction), 0)
def AddDevErrReaction(builder, devErrReaction):
    return AxsCfgAddDevErrReaction(builder, devErrReaction)
def AxsCfgAddRtInputs(builder, rtInputs): builder.PrependUOffsetTRelativeSlot(8, flatbuffers.number_types.UOffsetTFlags.py_type(rtInputs), 0)
def AddRtInputs(builder, rtInputs):
    return AxsCfgAddRtInputs(builder, rtInputs)
def AxsCfgEnd(builder): return builder.EndObject()
def End(builder):
    return AxsCfgEnd(builder)
import motion.core.fbtypes.AxsCfgDeviceErrorReaction
import motion.core.fbtypes.AxsCfgFunctions
import motion.core.fbtypes.AxsCfgKinProperties
import motion.core.fbtypes.AxsCfgLimits
import motion.core.fbtypes.AxsCfgProperties
import motion.core.fbtypes.RTInputsCfg
import motion.core.fbtypes.UnitCfgObj
try:
    from typing import Optional
except:
    pass

class AxsCfgT(object):

    # AxsCfgT
    def __init__(self):
        self.objectType = None  # type: str
        self.axisProfileName = None  # type: str
        self.limits = None  # type: Optional[motion.core.fbtypes.AxsCfgLimits.AxsCfgLimitsT]
        self.functions = None  # type: Optional[motion.core.fbtypes.AxsCfgFunctions.AxsCfgFunctionsT]
        self.properties = None  # type: Optional[motion.core.fbtypes.AxsCfgProperties.AxsCfgPropertiesT]
        self.units = None  # type: Optional[motion.core.fbtypes.UnitCfgObj.UnitCfgObjT]
        self.kinProperties = None  # type: Optional[motion.core.fbtypes.AxsCfgKinProperties.AxsCfgKinPropertiesT]
        self.devErrReaction = None  # type: Optional[motion.core.fbtypes.AxsCfgDeviceErrorReaction.AxsCfgDeviceErrorReactionT]
        self.rtInputs = None  # type: Optional[motion.core.fbtypes.RTInputsCfg.RTInputsCfgT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        axsCfg = AxsCfg()
        axsCfg.Init(buf, pos)
        return cls.InitFromObj(axsCfg)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, axsCfg):
        x = AxsCfgT()
        x._UnPack(axsCfg)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.objectType == other.objectType and \
            self.axisProfileName == other.axisProfileName and \
            self.limits == other.limits and \
            self.functions == other.functions and \
            self.properties == other.properties and \
            self.units == other.units and \
            self.kinProperties == other.kinProperties and \
            self.devErrReaction == other.devErrReaction and \
            self.rtInputs == other.rtInputs

    # AxsCfgT
    def _UnPack(self, axsCfg):
        if axsCfg is None:
            return
        self.objectType = axsCfg.ObjectType()
        self.axisProfileName = axsCfg.AxisProfileName()
        if axsCfg.Limits() is not None:
            self.limits = motion.core.fbtypes.AxsCfgLimits.AxsCfgLimitsT.InitFromObj(axsCfg.Limits())
        if axsCfg.Functions() is not None:
            self.functions = motion.core.fbtypes.AxsCfgFunctions.AxsCfgFunctionsT.InitFromObj(axsCfg.Functions())
        if axsCfg.Properties() is not None:
            self.properties = motion.core.fbtypes.AxsCfgProperties.AxsCfgPropertiesT.InitFromObj(axsCfg.Properties())
        if axsCfg.Units() is not None:
            self.units = motion.core.fbtypes.UnitCfgObj.UnitCfgObjT.InitFromObj(axsCfg.Units())
        if axsCfg.KinProperties() is not None:
            self.kinProperties = motion.core.fbtypes.AxsCfgKinProperties.AxsCfgKinPropertiesT.InitFromObj(axsCfg.KinProperties())
        if axsCfg.DevErrReaction() is not None:
            self.devErrReaction = motion.core.fbtypes.AxsCfgDeviceErrorReaction.AxsCfgDeviceErrorReactionT.InitFromObj(axsCfg.DevErrReaction())
        if axsCfg.RtInputs() is not None:
            self.rtInputs = motion.core.fbtypes.RTInputsCfg.RTInputsCfgT.InitFromObj(axsCfg.RtInputs())

    # AxsCfgT
    def Pack(self, builder):
        if self.objectType is not None:
            objectType = builder.CreateString(self.objectType)
        if self.axisProfileName is not None:
            axisProfileName = builder.CreateString(self.axisProfileName)
        if self.limits is not None:
            limits = self.limits.Pack(builder)
        if self.functions is not None:
            functions = self.functions.Pack(builder)
        if self.properties is not None:
            properties = self.properties.Pack(builder)
        if self.units is not None:
            units = self.units.Pack(builder)
        if self.kinProperties is not None:
            kinProperties = self.kinProperties.Pack(builder)
        if self.devErrReaction is not None:
            devErrReaction = self.devErrReaction.Pack(builder)
        if self.rtInputs is not None:
            rtInputs = self.rtInputs.Pack(builder)
        AxsCfgStart(builder)
        if self.objectType is not None:
            AxsCfgAddObjectType(builder, objectType)
        if self.axisProfileName is not None:
            AxsCfgAddAxisProfileName(builder, axisProfileName)
        if self.limits is not None:
            AxsCfgAddLimits(builder, limits)
        if self.functions is not None:
            AxsCfgAddFunctions(builder, functions)
        if self.properties is not None:
            AxsCfgAddProperties(builder, properties)
        if self.units is not None:
            AxsCfgAddUnits(builder, units)
        if self.kinProperties is not None:
            AxsCfgAddKinProperties(builder, kinProperties)
        if self.devErrReaction is not None:
            AxsCfgAddDevErrReaction(builder, devErrReaction)
        if self.rtInputs is not None:
            AxsCfgAddRtInputs(builder, rtInputs)
        axsCfg = AxsCfgEnd(builder)
        return axsCfg
