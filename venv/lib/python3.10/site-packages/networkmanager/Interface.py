# automatically generated by the FlatBuffers compiler, do not modify

# namespace: networkmanager

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Interface(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Interface()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsInterface(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Interface
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Interface
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Interface
    def Addresses(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from networkmanager.Address import Address
            obj = Address()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Interface
    def AddressesLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Interface
    def AddressesIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        return o == 0

    # Interface
    def HardwareAddress(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Interface
    def Link(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Interface
    def Disabled(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Interface
    def Kind(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Interface
    def Mode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Interface
    def Ssids(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from networkmanager.Ssid import Ssid
            obj = Ssid()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Interface
    def SsidsLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Interface
    def SsidsIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        return o == 0

    # Interface
    def IpForwarding(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return bool(self._tab.Get(flatbuffers.number_types.BoolFlags, o + self._tab.Pos))
        return False

    # Interface
    def State(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from networkmanager.State import State
            obj = State()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def InterfaceStart(builder): builder.StartObject(10)
def Start(builder):
    return InterfaceStart(builder)
def InterfaceAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def AddName(builder, name):
    return InterfaceAddName(builder, name)
def InterfaceAddAddresses(builder, addresses): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(addresses), 0)
def AddAddresses(builder, addresses):
    return InterfaceAddAddresses(builder, addresses)
def InterfaceStartAddressesVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartAddressesVector(builder, numElems):
    return InterfaceStartAddressesVector(builder, numElems)
def InterfaceAddHardwareAddress(builder, hardwareAddress): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(hardwareAddress), 0)
def AddHardwareAddress(builder, hardwareAddress):
    return InterfaceAddHardwareAddress(builder, hardwareAddress)
def InterfaceAddLink(builder, link): builder.PrependBoolSlot(3, link, 0)
def AddLink(builder, link):
    return InterfaceAddLink(builder, link)
def InterfaceAddDisabled(builder, disabled): builder.PrependBoolSlot(4, disabled, 0)
def AddDisabled(builder, disabled):
    return InterfaceAddDisabled(builder, disabled)
def InterfaceAddKind(builder, kind): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(kind), 0)
def AddKind(builder, kind):
    return InterfaceAddKind(builder, kind)
def InterfaceAddMode(builder, mode): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(mode), 0)
def AddMode(builder, mode):
    return InterfaceAddMode(builder, mode)
def InterfaceAddSsids(builder, ssids): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(ssids), 0)
def AddSsids(builder, ssids):
    return InterfaceAddSsids(builder, ssids)
def InterfaceStartSsidsVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartSsidsVector(builder, numElems):
    return InterfaceStartSsidsVector(builder, numElems)
def InterfaceAddIpForwarding(builder, ipForwarding): builder.PrependBoolSlot(8, ipForwarding, 0)
def AddIpForwarding(builder, ipForwarding):
    return InterfaceAddIpForwarding(builder, ipForwarding)
def InterfaceAddState(builder, state): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(state), 0)
def AddState(builder, state):
    return InterfaceAddState(builder, state)
def InterfaceEnd(builder): return builder.EndObject()
def End(builder):
    return InterfaceEnd(builder)
import networkmanager.Address
import networkmanager.Ssid
import networkmanager.State
try:
    from typing import List, Optional
except:
    pass

class InterfaceT(object):

    # InterfaceT
    def __init__(self):
        self.name = None  # type: str
        self.addresses = None  # type: List[networkmanager.Address.AddressT]
        self.hardwareAddress = None  # type: str
        self.link = False  # type: bool
        self.disabled = False  # type: bool
        self.kind = None  # type: str
        self.mode = None  # type: str
        self.ssids = None  # type: List[networkmanager.Ssid.SsidT]
        self.ipForwarding = False  # type: bool
        self.state = None  # type: Optional[networkmanager.State.StateT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        interface = Interface()
        interface.Init(buf, pos)
        return cls.InitFromObj(interface)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, interface):
        x = InterfaceT()
        x._UnPack(interface)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.name == other.name and \
            self.addresses == other.addresses and \
            self.hardwareAddress == other.hardwareAddress and \
            self.link == other.link and \
            self.disabled == other.disabled and \
            self.kind == other.kind and \
            self.mode == other.mode and \
            self.ssids == other.ssids and \
            self.ipForwarding == other.ipForwarding and \
            self.state == other.state

    # InterfaceT
    def _UnPack(self, interface):
        if interface is None:
            return
        self.name = interface.Name()
        if not interface.AddressesIsNone():
            self.addresses = []
            for i in range(interface.AddressesLength()):
                if interface.Addresses(i) is None:
                    self.addresses.append(None)
                else:
                    address_ = networkmanager.Address.AddressT.InitFromObj(interface.Addresses(i))
                    self.addresses.append(address_)
        self.hardwareAddress = interface.HardwareAddress()
        self.link = interface.Link()
        self.disabled = interface.Disabled()
        self.kind = interface.Kind()
        self.mode = interface.Mode()
        if not interface.SsidsIsNone():
            self.ssids = []
            for i in range(interface.SsidsLength()):
                if interface.Ssids(i) is None:
                    self.ssids.append(None)
                else:
                    ssid_ = networkmanager.Ssid.SsidT.InitFromObj(interface.Ssids(i))
                    self.ssids.append(ssid_)
        self.ipForwarding = interface.IpForwarding()
        if interface.State() is not None:
            self.state = networkmanager.State.StateT.InitFromObj(interface.State())

    # InterfaceT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.addresses is not None:
            addresseslist = []
            for i in range(len(self.addresses)):
                addresseslist.append(self.addresses[i].Pack(builder))
            InterfaceStartAddressesVector(builder, len(self.addresses))
            for i in reversed(range(len(self.addresses))):
                builder.PrependUOffsetTRelative(addresseslist[i])
            addresses = builder.EndVector()
        if self.hardwareAddress is not None:
            hardwareAddress = builder.CreateString(self.hardwareAddress)
        if self.kind is not None:
            kind = builder.CreateString(self.kind)
        if self.mode is not None:
            mode = builder.CreateString(self.mode)
        if self.ssids is not None:
            ssidslist = []
            for i in range(len(self.ssids)):
                ssidslist.append(self.ssids[i].Pack(builder))
            InterfaceStartSsidsVector(builder, len(self.ssids))
            for i in reversed(range(len(self.ssids))):
                builder.PrependUOffsetTRelative(ssidslist[i])
            ssids = builder.EndVector()
        if self.state is not None:
            state = self.state.Pack(builder)
        InterfaceStart(builder)
        if self.name is not None:
            InterfaceAddName(builder, name)
        if self.addresses is not None:
            InterfaceAddAddresses(builder, addresses)
        if self.hardwareAddress is not None:
            InterfaceAddHardwareAddress(builder, hardwareAddress)
        InterfaceAddLink(builder, self.link)
        InterfaceAddDisabled(builder, self.disabled)
        if self.kind is not None:
            InterfaceAddKind(builder, kind)
        if self.mode is not None:
            InterfaceAddMode(builder, mode)
        if self.ssids is not None:
            InterfaceAddSsids(builder, ssids)
        InterfaceAddIpForwarding(builder, self.ipForwarding)
        if self.state is not None:
            InterfaceAddState(builder, state)
        interface = InterfaceEnd(builder)
        return interface
