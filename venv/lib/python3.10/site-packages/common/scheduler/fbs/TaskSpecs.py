# automatically generated by the FlatBuffers compiler, do not modify

# namespace: fbs

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

# Task specifications to defined callable environment
class TaskSpecs(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = TaskSpecs()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsTaskSpecs(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # TaskSpecs
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Task name to link callables together within a task, e.g. "ctrlXAutomation" or "schedBackground"
    #   Allowed characters:
    #     Any alphanumeric character, beginning with a letter and a maximum length of 15 characters [a-zA-Z][a-zA-Z0-9]{1,15}
    # TaskSpecs
    def Name(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Task priority as well defined digit or range, e.g. "29" or "mid" to runs with medium priority
    #   Priority ranges:
    #       0 ..  10  : reserved for the system
    #      11 ..  99  : available for real-time user tasks
    #     100 .. 139  : available for non real-time user tasks
    #   Priority agreements:
    #      10         : reserved for Scheduler tick task 'schedMain'
    #      11         : highest prior real-time task, use of the policy FIFO policy
    #      23         : high prior real-time task, use of the policy FIFO policy
    #      29         : mid prior real-time task, use of the policy FIFO policy
    #      37         : low prior real-time task, use of the policy FIFO policy
    #      99         : lowest prior real-time task, use of the policy round-robin policy
    #     100         : highest prior non real-time task, use of the nice value of '-20'
    #     120         : common used non real-time task, use of the nice value of '0'
    #     139         : lowest prior non real-time task, use of the nice value of '19'
    #     high        : see (23), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "high+1" results (24)
    #     mid         : see (29), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "mid-2" results (27)
    #     low         : see (37), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "low+3" results (40)
    #     nrt         : see (120), can be extended by operator '+' resp. '-' and in additional any digit offset, e.g. "nrt-10" results a nice value of (-10)
    # TaskSpecs
    def Priority(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Description of required task properties, e.g. "cyclic/ms/10" to runs cyclic every 10 millisecond
    # The notation of the task properties depends on supported task types.
    # Notation of cyclic tasks, separated by '/'
    #   event           : Execution event of the task ["cyclic"]
    #   cycle time unit : Supported units are millisecond ["ms"] and microsecond ["Âµs"]
    #   digit           : Any digit [0-9]+
    # TaskSpecs
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Preferred CPU index on which the task should run
    # Is composed of the preferred CPU type and an index.
    # The cpu type can be 'rt' for isolated cores or 'nrt' for non-isolated cores.
    # The index represents the element of a list sorted in ascending order.
    # If multiple CPU indices are desired they have been separated by ','.
    # If the desired cpu core is not available the CPU core with the highest index of that type is used.
    # If 'rt' type is desired and no real time core is available the non-real time core with the highest index is used. At least one 'nrt' core must be available.
    # When multiple CPU indices are set and no exact matching core is available the the CPU core with the highest index of that type is used.
    #   Allowed values:
    #     "rt" -> The real time core (isolated core) with the highest index is used. If a real time core is available.
    #     "nrt" -> The non real time core with the highest index is used.
    #     "rt/1" -> The real time core with index 1 is used if it is available.
    #     "rt/5,rt/3,rt/0,nrt/5" -> Iterating over all elements and use first matching core.
    # TaskSpecs
    def CpuIndex(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

def TaskSpecsStart(builder): builder.StartObject(4)
def Start(builder):
    return TaskSpecsStart(builder)
def TaskSpecsAddName(builder, name): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(name), 0)
def AddName(builder, name):
    return TaskSpecsAddName(builder, name)
def TaskSpecsAddPriority(builder, priority): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(priority), 0)
def AddPriority(builder, priority):
    return TaskSpecsAddPriority(builder, priority)
def TaskSpecsAddType(builder, type): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)
def AddType(builder, type):
    return TaskSpecsAddType(builder, type)
def TaskSpecsAddCpuIndex(builder, cpuIndex): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(cpuIndex), 0)
def AddCpuIndex(builder, cpuIndex):
    return TaskSpecsAddCpuIndex(builder, cpuIndex)
def TaskSpecsEnd(builder): return builder.EndObject()
def End(builder):
    return TaskSpecsEnd(builder)

class TaskSpecsT(object):

    # TaskSpecsT
    def __init__(self):
        self.name = None  # type: str
        self.priority = None  # type: str
        self.type = None  # type: str
        self.cpuIndex = None  # type: str

    @classmethod
    def InitFromBuf(cls, buf, pos):
        taskSpecs = TaskSpecs()
        taskSpecs.Init(buf, pos)
        return cls.InitFromObj(taskSpecs)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, taskSpecs):
        x = TaskSpecsT()
        x._UnPack(taskSpecs)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.name == other.name and \
            self.priority == other.priority and \
            self.type == other.type and \
            self.cpuIndex == other.cpuIndex

    # TaskSpecsT
    def _UnPack(self, taskSpecs):
        if taskSpecs is None:
            return
        self.name = taskSpecs.Name()
        self.priority = taskSpecs.Priority()
        self.type = taskSpecs.Type()
        self.cpuIndex = taskSpecs.CpuIndex()

    # TaskSpecsT
    def Pack(self, builder):
        if self.name is not None:
            name = builder.CreateString(self.name)
        if self.priority is not None:
            priority = builder.CreateString(self.priority)
        if self.type is not None:
            type = builder.CreateString(self.type)
        if self.cpuIndex is not None:
            cpuIndex = builder.CreateString(self.cpuIndex)
        TaskSpecsStart(builder)
        if self.name is not None:
            TaskSpecsAddName(builder, name)
        if self.priority is not None:
            TaskSpecsAddPriority(builder, priority)
        if self.type is not None:
            TaskSpecsAddType(builder, type)
        if self.cpuIndex is not None:
            TaskSpecsAddCpuIndex(builder, cpuIndex)
        taskSpecs = TaskSpecsEnd(builder)
        return taskSpecs
