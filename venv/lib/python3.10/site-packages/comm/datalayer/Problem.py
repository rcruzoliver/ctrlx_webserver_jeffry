# automatically generated by the FlatBuffers compiler, do not modify

# namespace: datalayer

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Problem(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Problem()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsProblem(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Problem
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # A URI reference [RFC3986] that identifies the problem type. 
    # This specification encourages that, when dereferenced, 
    # it provide human-readable documentation for the problem type 
    # (e.g., using HTML [W3C.REC-html5-20141028]). When this member 
    # is not present, its value is assumed to be "about:blank".
    # Problem
    def Type(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # A short, human-readable summary of the problem type. 
    # It SHOULD NOT change from occurrence to occurrence of the problem, 
    # except for purposes of localization (e.g., using proactive content 
    # negotiation; see [RFC7231], Section 3.4).
    # Problem
    def Title(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
    # This will be added by the webserver - so you don't have to fill this field.
    # Problem
    def Status(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int32Flags, o + self._tab.Pos)
        return 0

    # A human-readable explanation specific to this occurrence of the problem.
    # Problem
    def Detail(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(10))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
    # Problem
    def Instance(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(12))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The main diagnosis code was/is issued by the system that caused the problem.
    # This code can be used to track down the root cause and source of the error.
    # It can be used to search in the documentation for a solution.
    # It SHOULD NOT change from occurrence to occurrence of the same problem.
    # example: 080F0100
    # Problem
    def MainDiagnosisCode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(14))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # The detailed diagnosis code issued by the system that caused the problem.
    # This code can be used to track down the detailed cause and source of the error.
    # It can be used to search in the documentation for a solution.
    # The detailed diagnosis code gives additional information about the cause of the error.
    # It SHOULD NOT change from occurrence to occurrence of the same problem.
    # example: 00666001
    # Problem
    def DetailedDiagnosisCode(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(16))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # A dynamic description gives detailed information about the occurrence of a problem.
    # It can change between different occurrences of the same error.
    # example: value = -4.5
    # Problem
    def DynamicDescription(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(18))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Severity of a problem as defined RFC5424 of the Syslog standard, see https://tools.ietf.org/html/rfc5424'
    # Problem
    def Severity(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(20))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int8Flags, o + self._tab.Pos)
        return 0

    # Collection of links to fix the problem. E.g. links to online user manual, to an online community (using tags) or a developer chat (e.g. Slack).
    # Problem
    def Links(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.String(a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 4))
        return ""

    # Problem
    def LinksLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Problem
    def LinksIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(22))
        return o == 0

    # Resource or entity which causes the problem
    # Problem
    def Entity(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(24))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # More information about the problem (key/value pair)
    # Problem
    def MoreInfo(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            a = self._tab.Vector(o)
            return self._tab.Get(flatbuffers.number_types.Uint8Flags, a + flatbuffers.number_types.UOffsetTFlags.py_type(j * 1))
        return 0

    # Problem
    def MoreInfoAsNumpy(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, o)
        return 0

    # Problem
    def MoreInfoLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Problem
    def MoreInfoIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(26))
        return o == 0

    # Cause of the problem
    # Problem
    def Cause(self, j):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            x = self._tab.Vector(o)
            x += flatbuffers.number_types.UOffsetTFlags.py_type(j) * 4
            x = self._tab.Indirect(x)
            from comm.datalayer.Problem import Problem
            obj = Problem()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

    # Problem
    def CauseLength(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        if o != 0:
            return self._tab.VectorLen(o)
        return 0

    # Problem
    def CauseIsNone(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(28))
        return o == 0

def ProblemStart(builder): builder.StartObject(13)
def Start(builder):
    return ProblemStart(builder)
def ProblemAddType(builder, type): builder.PrependUOffsetTRelativeSlot(0, flatbuffers.number_types.UOffsetTFlags.py_type(type), 0)
def AddType(builder, type):
    return ProblemAddType(builder, type)
def ProblemAddTitle(builder, title): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(title), 0)
def AddTitle(builder, title):
    return ProblemAddTitle(builder, title)
def ProblemAddStatus(builder, status): builder.PrependInt32Slot(2, status, 0)
def AddStatus(builder, status):
    return ProblemAddStatus(builder, status)
def ProblemAddDetail(builder, detail): builder.PrependUOffsetTRelativeSlot(3, flatbuffers.number_types.UOffsetTFlags.py_type(detail), 0)
def AddDetail(builder, detail):
    return ProblemAddDetail(builder, detail)
def ProblemAddInstance(builder, instance): builder.PrependUOffsetTRelativeSlot(4, flatbuffers.number_types.UOffsetTFlags.py_type(instance), 0)
def AddInstance(builder, instance):
    return ProblemAddInstance(builder, instance)
def ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode): builder.PrependUOffsetTRelativeSlot(5, flatbuffers.number_types.UOffsetTFlags.py_type(mainDiagnosisCode), 0)
def AddMainDiagnosisCode(builder, mainDiagnosisCode):
    return ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode)
def ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode): builder.PrependUOffsetTRelativeSlot(6, flatbuffers.number_types.UOffsetTFlags.py_type(detailedDiagnosisCode), 0)
def AddDetailedDiagnosisCode(builder, detailedDiagnosisCode):
    return ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode)
def ProblemAddDynamicDescription(builder, dynamicDescription): builder.PrependUOffsetTRelativeSlot(7, flatbuffers.number_types.UOffsetTFlags.py_type(dynamicDescription), 0)
def AddDynamicDescription(builder, dynamicDescription):
    return ProblemAddDynamicDescription(builder, dynamicDescription)
def ProblemAddSeverity(builder, severity): builder.PrependInt8Slot(8, severity, 0)
def AddSeverity(builder, severity):
    return ProblemAddSeverity(builder, severity)
def ProblemAddLinks(builder, links): builder.PrependUOffsetTRelativeSlot(9, flatbuffers.number_types.UOffsetTFlags.py_type(links), 0)
def AddLinks(builder, links):
    return ProblemAddLinks(builder, links)
def ProblemStartLinksVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartLinksVector(builder, numElems):
    return ProblemStartLinksVector(builder, numElems)
def ProblemAddEntity(builder, entity): builder.PrependUOffsetTRelativeSlot(10, flatbuffers.number_types.UOffsetTFlags.py_type(entity), 0)
def AddEntity(builder, entity):
    return ProblemAddEntity(builder, entity)
def ProblemAddMoreInfo(builder, moreInfo): builder.PrependUOffsetTRelativeSlot(11, flatbuffers.number_types.UOffsetTFlags.py_type(moreInfo), 0)
def AddMoreInfo(builder, moreInfo):
    return ProblemAddMoreInfo(builder, moreInfo)
def ProblemStartMoreInfoVector(builder, numElems): return builder.StartVector(1, numElems, 1)
def StartMoreInfoVector(builder, numElems):
    return ProblemStartMoreInfoVector(builder, numElems)
def ProblemAddCause(builder, cause): builder.PrependUOffsetTRelativeSlot(12, flatbuffers.number_types.UOffsetTFlags.py_type(cause), 0)
def AddCause(builder, cause):
    return ProblemAddCause(builder, cause)
def ProblemStartCauseVector(builder, numElems): return builder.StartVector(4, numElems, 4)
def StartCauseVector(builder, numElems):
    return ProblemStartCauseVector(builder, numElems)
def ProblemEnd(builder): return builder.EndObject()
def End(builder):
    return ProblemEnd(builder)
try:
    from typing import List
except:
    pass

class ProblemT(object):

    # ProblemT
    def __init__(self):
        self.type = None  # type: str
        self.title = None  # type: str
        self.status = 0  # type: int
        self.detail = None  # type: str
        self.instance = None  # type: str
        self.mainDiagnosisCode = None  # type: str
        self.detailedDiagnosisCode = None  # type: str
        self.dynamicDescription = None  # type: str
        self.severity = 0  # type: int
        self.links = None  # type: List[str]
        self.entity = None  # type: str
        self.moreInfo = None  # type: List[int]
        self.cause = None  # type: List[comm.datalayer.Problem.ProblemT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        problem = Problem()
        problem.Init(buf, pos)
        return cls.InitFromObj(problem)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, problem):
        x = ProblemT()
        x._UnPack(problem)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.type == other.type and \
            self.title == other.title and \
            self.status == other.status and \
            self.detail == other.detail and \
            self.instance == other.instance and \
            self.mainDiagnosisCode == other.mainDiagnosisCode and \
            self.detailedDiagnosisCode == other.detailedDiagnosisCode and \
            self.dynamicDescription == other.dynamicDescription and \
            self.severity == other.severity and \
            self.links == other.links and \
            self.entity == other.entity and \
            self.moreInfo == other.moreInfo and \
            self.cause == other.cause

    # ProblemT
    def _UnPack(self, problem):
        if problem is None:
            return
        self.type = problem.Type()
        self.title = problem.Title()
        self.status = problem.Status()
        self.detail = problem.Detail()
        self.instance = problem.Instance()
        self.mainDiagnosisCode = problem.MainDiagnosisCode()
        self.detailedDiagnosisCode = problem.DetailedDiagnosisCode()
        self.dynamicDescription = problem.DynamicDescription()
        self.severity = problem.Severity()
        if not problem.LinksIsNone():
            self.links = []
            for i in range(problem.LinksLength()):
                self.links.append(problem.Links(i))
        self.entity = problem.Entity()
        if not problem.MoreInfoIsNone():
            if np is None:
                self.moreInfo = []
                for i in range(problem.MoreInfoLength()):
                    self.moreInfo.append(problem.MoreInfo(i))
            else:
                self.moreInfo = problem.MoreInfoAsNumpy()
        if not problem.CauseIsNone():
            self.cause = []
            for i in range(problem.CauseLength()):
                if problem.Cause(i) is None:
                    self.cause.append(None)
                else:
                    problem_ = comm.datalayer.Problem.ProblemT.InitFromObj(problem.Cause(i))
                    self.cause.append(problem_)

    # ProblemT
    def Pack(self, builder):
        if self.type is not None:
            type = builder.CreateString(self.type)
        if self.title is not None:
            title = builder.CreateString(self.title)
        if self.detail is not None:
            detail = builder.CreateString(self.detail)
        if self.instance is not None:
            instance = builder.CreateString(self.instance)
        if self.mainDiagnosisCode is not None:
            mainDiagnosisCode = builder.CreateString(self.mainDiagnosisCode)
        if self.detailedDiagnosisCode is not None:
            detailedDiagnosisCode = builder.CreateString(self.detailedDiagnosisCode)
        if self.dynamicDescription is not None:
            dynamicDescription = builder.CreateString(self.dynamicDescription)
        if self.links is not None:
            linkslist = []
            for i in range(len(self.links)):
                linkslist.append(builder.CreateString(self.links[i]))
            ProblemStartLinksVector(builder, len(self.links))
            for i in reversed(range(len(self.links))):
                builder.PrependUOffsetTRelative(linkslist[i])
            links = builder.EndVector()
        if self.entity is not None:
            entity = builder.CreateString(self.entity)
        if self.moreInfo is not None:
            if np is not None and type(self.moreInfo) is np.ndarray:
                moreInfo = builder.CreateNumpyVector(self.moreInfo)
            else:
                ProblemStartMoreInfoVector(builder, len(self.moreInfo))
                for i in reversed(range(len(self.moreInfo))):
                    builder.PrependUint8(self.moreInfo[i])
                moreInfo = builder.EndVector()
        if self.cause is not None:
            causelist = []
            for i in range(len(self.cause)):
                causelist.append(self.cause[i].Pack(builder))
            ProblemStartCauseVector(builder, len(self.cause))
            for i in reversed(range(len(self.cause))):
                builder.PrependUOffsetTRelative(causelist[i])
            cause = builder.EndVector()
        ProblemStart(builder)
        if self.type is not None:
            ProblemAddType(builder, type)
        if self.title is not None:
            ProblemAddTitle(builder, title)
        ProblemAddStatus(builder, self.status)
        if self.detail is not None:
            ProblemAddDetail(builder, detail)
        if self.instance is not None:
            ProblemAddInstance(builder, instance)
        if self.mainDiagnosisCode is not None:
            ProblemAddMainDiagnosisCode(builder, mainDiagnosisCode)
        if self.detailedDiagnosisCode is not None:
            ProblemAddDetailedDiagnosisCode(builder, detailedDiagnosisCode)
        if self.dynamicDescription is not None:
            ProblemAddDynamicDescription(builder, dynamicDescription)
        ProblemAddSeverity(builder, self.severity)
        if self.links is not None:
            ProblemAddLinks(builder, links)
        if self.entity is not None:
            ProblemAddEntity(builder, entity)
        if self.moreInfo is not None:
            ProblemAddMoreInfo(builder, moreInfo)
        if self.cause is not None:
            ProblemAddCause(builder, cause)
        problem = ProblemEnd(builder)
        return problem
