# automatically generated by the FlatBuffers compiler, do not modify

# namespace: systeminfo

import flatbuffers
from flatbuffers.compat import import_numpy
np = import_numpy()

class Cpu(object):
    __slots__ = ['_tab']

    @classmethod
    def GetRootAs(cls, buf, offset=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        x = Cpu()
        x.Init(buf, n + offset)
        return x

    @classmethod
    def GetRootAsCpu(cls, buf, offset=0):
        """This method is deprecated. Please switch to GetRootAs."""
        return cls.GetRootAs(buf, offset)
    # Cpu
    def Init(self, buf, pos):
        self._tab = flatbuffers.table.Table(buf, pos)

    # Cpu
    def MaxFrequency(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(4))
        if o != 0:
            return self._tab.Get(flatbuffers.number_types.Int64Flags, o + self._tab.Pos)
        return 0

    # Cpu
    def Architecture(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(6))
        if o != 0:
            return self._tab.String(o + self._tab.Pos)
        return None

    # Cpu
    def Cores(self):
        o = flatbuffers.number_types.UOffsetTFlags.py_type(self._tab.Offset(8))
        if o != 0:
            x = self._tab.Indirect(o + self._tab.Pos)
            from systeminfo.Cores import Cores
            obj = Cores()
            obj.Init(self._tab.Bytes, x)
            return obj
        return None

def CpuStart(builder): builder.StartObject(3)
def Start(builder):
    return CpuStart(builder)
def CpuAddMaxFrequency(builder, maxFrequency): builder.PrependInt64Slot(0, maxFrequency, 0)
def AddMaxFrequency(builder, maxFrequency):
    return CpuAddMaxFrequency(builder, maxFrequency)
def CpuAddArchitecture(builder, architecture): builder.PrependUOffsetTRelativeSlot(1, flatbuffers.number_types.UOffsetTFlags.py_type(architecture), 0)
def AddArchitecture(builder, architecture):
    return CpuAddArchitecture(builder, architecture)
def CpuAddCores(builder, cores): builder.PrependUOffsetTRelativeSlot(2, flatbuffers.number_types.UOffsetTFlags.py_type(cores), 0)
def AddCores(builder, cores):
    return CpuAddCores(builder, cores)
def CpuEnd(builder): return builder.EndObject()
def End(builder):
    return CpuEnd(builder)
import systeminfo.Cores
try:
    from typing import Optional
except:
    pass

class CpuT(object):

    # CpuT
    def __init__(self):
        self.maxFrequency = 0  # type: int
        self.architecture = None  # type: str
        self.cores = None  # type: Optional[systeminfo.Cores.CoresT]

    @classmethod
    def InitFromBuf(cls, buf, pos):
        cpu = Cpu()
        cpu.Init(buf, pos)
        return cls.InitFromObj(cpu)

    @classmethod
    def InitFromPackedBuf(cls, buf, pos=0):
        n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, pos)
        return cls.InitFromBuf(buf, pos+n)

    @classmethod
    def InitFromObj(cls, cpu):
        x = CpuT()
        x._UnPack(cpu)
        return x

    def __eq__(self, other):
        return type(self) == type(other) and \
            self.maxFrequency == other.maxFrequency and \
            self.architecture == other.architecture and \
            self.cores == other.cores

    # CpuT
    def _UnPack(self, cpu):
        if cpu is None:
            return
        self.maxFrequency = cpu.MaxFrequency()
        self.architecture = cpu.Architecture()
        if cpu.Cores() is not None:
            self.cores = systeminfo.Cores.CoresT.InitFromObj(cpu.Cores())

    # CpuT
    def Pack(self, builder):
        if self.architecture is not None:
            architecture = builder.CreateString(self.architecture)
        if self.cores is not None:
            cores = self.cores.Pack(builder)
        CpuStart(builder)
        CpuAddMaxFrequency(builder, self.maxFrequency)
        if self.architecture is not None:
            CpuAddArchitecture(builder, architecture)
        if self.cores is not None:
            CpuAddCores(builder, cores)
        cpu = CpuEnd(builder)
        return cpu
